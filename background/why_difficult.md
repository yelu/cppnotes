# 学习C++的困难来自何处

C++学习起来曲线较陡，似乎成了共识。造成这一现象的原因是什么，能被阐明的理由早已被拿出来说了无数遍。但是，这其中有些理由是大道理，懂了也没什么实际帮助，例如C++语法太多、标准进化太快。又有一些
带有偏见，例如模板、元编程才是C++的精华。还有一些并未被提及，例如入门者本身的主观心态，已有的知识储备通常是怎样的？

有鉴于此，在真正能够运用C++之前，初学者很难能体会到它相比其它语言到底难在哪里。那这一节的存在还有必要吗？有，但只有换一种方式来描述才有可能。C++的困难之处并非语法本身带来，更深层的原因有二：

* C++提供了太多可能性，让权衡变得困难。
* 初学者从其它语言带来了固有看法，并用其审视C++。

## C++提供了太多可能性

总体上看，C++的语法特性确实是复杂度比较高的，而且还在持续地变得越来越复杂。

|语言|Keyword数量|
|--|--|
|C|[32](http://tigcc.ticalc.org/doc/keywords.html)|
|C++98|[79](https://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Keywords)|
|C++11|+12|
|C++20|+8|
|Java|[50](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)|
|.Net|[77+31](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/)|
|Python|[33](https://www.w3schools.com/python/python_ref_keywords.asp)|

这一点很容易被误读，语法集合的大小和使用的难易程度没有必然联系，最复杂的.Net反而不是那么难以上手。真正的原因我认为是C++提供了太多方式，同时又太过于自由，以至于完成一件事可以有很多种选择。从而产生了问题：
* 存在很多陷阱，在没有全面了解的情况下很容易掉入。
* 不同风格的开发者通常持有不同的观点或者是“信仰”，让人眼花缭乱。

通过“字符串连接”这个简单的例子就能很快了解这个问题。

如果是python，除非及其特殊的原因，几乎不会有人写出以下实现之外的第二种实现：

```python
def cat_str(a: str, b: str):
    return a + b
```

到了C++这里麻烦就很大，首先执着于C的程序员可能会马上开始提意见：字符串是用char*来存储，我不习惯用C++的std::string类。那么存访结果的buffer在哪？又是一次选择的开始：

* 谁申请谁释放原则。存访结果的数组以参数的形式传进去，再加一个大小防止函数写越界。
* 函数对外屏蔽实现原则。用多少申请多少，由函数内部分配并返回，调用者释放。

```c
void cat_str(char* a, char* b, char* dst, int n);
char* cat_str(char* a, char* b);
```

两者都是合法的，但是通常大家习惯采用第一种，即由调用者控制内存的申请，以尽量规避内存归属不清导致的泄露。初学者并不容易在没有经验的时候把握到这点。

回到习惯面向对象的开发者。如果不是性能要求特别苛刻，使用C++的std::string也能很简单直观地实现需求，但这其中还是有一些选择需要面对：
* 习惯性使用的语法，例如const、引用都为什么要用。
* 一些优化在不知不觉中进行，例如避免返回值拷贝的Named Return Value。

```c++
std::string cat_str(const std::string& a, const std::string& b)
{
    std::string res = a + b;
    return res;
}
```

所以，无所适从才是学习C++最头疼的事情。好像怎么做都行，但是一做就错，如履薄冰。

## 由其它语言带入的固有思维模式

走向C++的开发者通常有两类：

* 经常使用Java/.Net/Python的开发者，以下简称JNP开发者。
* 已经熟练掌握C的开发者。

JNP开发者们对C++复杂的认识有一部分是错觉。Java和.Net开发者99%甚至全部都会使用某一IDE来开发，这些语言都有中间虚拟机，语言标准由一家掌控，统一且跨平台一致，IDE可以做得非常完美，智能提示和补全在很大程度上弥补了语法特性带来的复杂性。而Python正是靠着符合直觉的语法设计备受亲睐。C/C++因为更加底层，通常难有好用的IDE，不同平台的开发工具链也不同，熟练的C++开发者都有随时脱离IDE面对Terminal进行开发的能力，这对语言掌握的要求就相对提高了。

JNP开发者还通常对系统资源（内存、CPU等）的关注不足，缺少一种在脑子里想象“现在写下的代码在怎样使用CPU，内存里在发生什么”的贯通性思考习惯，因为这一切都被虚拟机托管了。而这一习惯在理解C/C++怎样工作，定位复杂问题的时候相当重要。

```C++
// 调用如下函数，内存中的对象是怎样变化的？
std:vector<float> add_vectors(std::vector<float> a, std::vector<float> b)
{
    size_t n = a.size();
    std::vector<float> res(n, 0.0);
    for(auto i = 0; i < n; i++)
    {
        res[i] = a[i] + b[i];
    }
    return res;
}
```

对于熟练的C开发者，情况是不一样的。他们对底层资源有些良好的把控能力，即使不用C++，C语言本身也已经足够写出结构良好的代码。C语言紧凑且稳定的语法集合，“多一点显得邋遢，少一点显得不够”，比汇编好写，又能精准操纵系统资源，一切都刚刚好。对他们而言，只剩下愿不愿意进一步了解的问题，学习C++没有根本性的障碍。
