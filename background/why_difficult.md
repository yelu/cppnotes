# C++难在哪

C++是一门相对比较难以掌握的编程语言，造成这一现象的原因被认为是多种多样的。例如，C++语法太庞杂，标准进化太快，模板、元编程这些复杂的编程范式等等。这些解释提供了一些事实，但并不能为该怎样更好地学习C++提供指导。实际上，在能够合理运用C++之前，初学者很难真正体会到相比其它语言C++到底难在哪里，彻底回答这个问题需要结合多年的思考和体会。

本节尝试从侧面寻找一些非具体语法特性方面的原因。了解这些原因也许有助于清除一些陷阱和偏见，以一个更加全局的视角开始学习或者重新认识C++。

* C++提供了太多可能性，让权衡取舍变得困难。
* 把其它语言的固有思维模式带入C++。

## C++提供了太多可能性

总体上看，C++的语法特性确实复杂度比较高，而且还在持续变得越来越复杂。

|语言|Keyword数量|
|--|--|
|C|[32](http://tigcc.ticalc.org/doc/keywords.html)|
|C++98|[79](https://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Keywords)|
|C++11|+12|
|C++20|+8|
|Java|[50](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)|
|.Net|[77+31](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/)|
|Python|[33](https://www.w3schools.com/python/python_ref_keywords.asp)|

这一点很容易被误读，语法集合的大小和使用的难易程度没有必然联系，keyword最多的.Net反而不那么难上手。真正的原因是C++出于很多考虑提供了太多方式和自由度，以至于完成一件事可以有很多条道路，进而产生了选择性困难：
* 各种写法都多少存在一些陷阱，在没有全面了解的情况下很容易掉入。
* 不同风格的开发者通常持有不同的观点或者是“信仰”，坚持不同的实现，让人眼花缭乱。

通过“字符串连接”这个简单的例子能很快了解到问题所在。

如果是python，除非极其特殊的原因，几乎不会有人写出不同于以下实现的第二种实现：

```python
def concat_str(a: str, b: str):
    return a + b
```

到了C++这里麻烦就很大。首先执着于C的程序员可能会马上提出意见：字符串需要用char数组来存储，我不习惯用C++的std::string类。那么存放结果的buffer在哪？这又是一次选择的开始：

* 谁申请谁释放原则。存放结果的数组以参数的形式传进去，再加一个大小防止函数写越界。
* 函数对外屏蔽实现原则。用多少申请多少，由函数内部分配并返回，调用者释放。

```c
void concat_str(char* a, char* b, char* dst, int n);
char* concat_str(char* a, char* b);
```

两者都是合法的，但是通常大家习惯采用第一种，即由调用者控制内存的申请，以尽量规避内存归属不清导致的泄露。初学者并不容易在没有经验的时候把握到这一点。

回到习惯C++ std::string类的开发者，如果不是性能要求特别苛刻，使用std::string也能简单直观地实现功能，但这其中还是有一些选择需要面对：

* 常见的语法，例如const、引用，用还是不用？
* 该返回std::string吗？返回值的复制能避免吗？这牵涉到对NRV优化（Named Return Value），以及左值右值的了解。

```c++
std::string concat_str(const std::string& a, const std::string& b)
{
    std::string res = a + b;
    return res;
}
```

所以，无所适从才是头疼之处。好像怎么做都行，但是一做就错，如履薄冰。

## 从其它语言带入的固有思维模式

固有思维模式是一种先入为主的陷阱，它首先体现在对开发环境的要求上面。

经常使用Java/.Net/Python的开发者（以下简称JNP开发者）对C++复杂的认识有一部分是错觉。Java和.Net开发者99%都会使用某一IDE做开发，这些语言都有中间虚拟机，语言标准由一家掌控，统一且跨平台一致，IDE可以做得非常完美，智能提示和补全在很大程度上弥补了语法特性带来的复杂性。而Python正是靠着绝对符合直觉的语法设计才备受亲睐。

C/C++因为追求性能而不得不更加底层，不同平台的开发工具链不尽相同，各平台还有自己私有的系统API，导致媲美JNP开发体验的IDE是不存在的。熟练的C++开发者都有随时脱离IDE面对Terminal进行开发的能力，对语言掌握的要求就相对提高了。一些编译、链接的细节也需要开发者理解，并能亲自处理，缺乏掌握的后果可能是面对满屏的链接错误不知道何处下手。

固有思维模式带来的更致命的第二个问题是JNP开发者通常**对系统资源（内存、CPU等）的关注不足**，缺少一种在脑子里想象“现在写下的代码在怎样使用CPU，内存里在发生什么”的贯通性思考习惯，因为这一切都被虚拟机托管了。而这一习惯对于理解C/C++怎样工作、性能提升、定位复杂问题都至关重要。

```C++
// 调用如下函数，内存中的对象是怎样变化的？
std:vector<float> add_vectors(std::vector<float> a, std::vector<float> b)
{
    size_t n = a.size();
    std::vector<float> res(n, 0.0);
    for(auto i = 0; i < n; i++){
        res[i] = a[i] + b[i];
    }
    return res;
}
```

对于熟练的C开发者，情况就不一样了。他们对底层资源有良好的把控能力，即使不用C++，C语言本身也已经足够写出结构良好的代码。C语言有紧凑且稳定的语法集合，“多一点显得邋遢，少一点显得不够”，比汇编好写，又能精准操纵系统资源，一切都刚刚好。他们学习C++没有根本性的障碍，唯一的问题是愿不愿意进一步了解新的语法和编程范式。

## 如何学习？

有效地学习C++需要结合以下两个方面。

首先，认识、理解C++和系统资源（内存、CPU等）之间如何互动，把系统资源放在核心位置。资源利用率就是性能，而性能是C/C++永远不会妥协的重点。性能不会因为“使用了C++”而自动变好，而是需要对资源使用情况进行反复审视。

其次，认识、理解各种设计实现背后的原因和历史，进而拥有独立做出权衡取舍的能力。这需要在实践中逐步积累。机械地记忆条条框框无济于事，没有什么原则永远正确，没有什么模式放之四海皆准。C++的标准还在不断演进中，唯有理解背后的动机，以不变应万变，才能持续快速地吸收新的、对自己工作有帮助的语言特性。
