# 学习C++的困难来自何处

C++学习曲线陡峭，是一种共识。造成这一现象的原因是什么，能被阐明的理由都被拿出来说了很多遍。但是，这其中有些理由太大道理，听懂了也没什么实际帮助，例如C++语法太多、标准进化太快。又有一些
带有偏见，例如模板、元编程才是C++的巅峰和精华。还有一些很少被提及，例如入门者本身的主观心态，已有的知识储备通常是怎样的？

有鉴于此，在能够合理运用C++之前，初学者很难真正体会到相比其它语言C++到底难在哪里，形成了一个死结。本节无法完全打开这个结，只能试图让初学者尽可能感受到困难的本质在哪里。深入的理解还需要阅读后续章节，并在使用中不断体会。

本节的观点是C++的难并非是由其语法规则本身带来的，更深层的原因有二：

* C++提供了太多可能性，让权衡变得困难。
* 把其它语言的固有思维模式带入C++。

## C++提供了太多可能性

总体上看，C++的语法特性确实是复杂度比较高的，而且还在持续地变得越来越复杂。

|语言|Keyword数量|
|--|--|
|C|[32](http://tigcc.ticalc.org/doc/keywords.html)|
|C++98|[79](https://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Keywords)|
|C++11|+12|
|C++20|+8|
|Java|[50](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)|
|.Net|[77+31](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/)|
|Python|[33](https://www.w3schools.com/python/python_ref_keywords.asp)|

这一点很容易被误读，语法集合的大小和使用的难易程度没有必然联系，最复杂的.Net反而不是那么难以上手。真正的原因是C++出于很多考虑提供了太多方式和自由度，以至于完成一件事可以有很多条道路，进而产生了选择性困难：
* 各种写法都多少存在一些陷阱，在没有全面了解的情况下很容易掉入。
* 不同风格的开发者通常持有不同的观点或者是“信仰”，坚持不同的实现，让人眼花缭乱。

通过“字符串连接”这个简单的例子能很快了解到问题所在。

如果是python，除非极其特殊的原因，几乎不会有人写出不同于以下实现的第二种实现：

```python
def cat_str(a: str, b: str):
    return a + b
```

到了C++这里麻烦就很大。首先执着于C的程序员可能会马上提出意见：字符串需要用char数组来存储，我不习惯用C++的std::string类。那么存放结果的buffer在哪？这又是一次选择的开始：

* 谁申请谁释放原则。存放结果的数组以参数的形式传进去，再加一个大小防止函数写越界。
* 函数对外屏蔽实现原则。用多少申请多少，由函数内部分配并返回，调用者释放。

```c
void cat_str(char* a, char* b, char* dst, int n);
char* cat_str(char* a, char* b);
```

两者都是合法的，但是通常大家习惯采用第一种，即由调用者控制内存的申请，以尽量规避内存归属不清导致的泄露。初学者并不容易在没有经验的时候把握到这一点。

回到习惯面向对象的开发者，如果不是性能要求特别苛刻，使用C++的std::string也能简单直观地实现功能，但这其中还是有一些选择需要面对：
* 习惯性使用的语法，例如const、引用都为什么要用？
* 返回值的复制能否避免？这牵涉到了对NRV优化（Named Return Value），甚至左值右值的了解。

```c++
std::string cat_str(const std::string& a, const std::string& b)
{
    std::string res = a + b;
    return res;
}
```

所以，无所适从才是头疼之处。好像怎么做都行，但是一做就错，对了可能也是凑巧，如履薄冰。

## 从其它语言带入的固有思维模式

固有思维模式是一种先入为主的陷阱，它首先体现在对开发环境的要求上面。

经常使用Java/.Net/Python的开发者（以下简称JNP开发者）对C++复杂的认识有一部分是错觉。Java和.Net开发者99%甚至全部都会使用某一IDE来开发，这些语言都有中间虚拟机，语言标准由一家掌控，统一且跨平台一致，IDE可以做得非常完美，智能提示和补全在很大程度上弥补了语法特性带来的复杂性。而Python正是靠着绝对符合直觉的语法设计才备受亲睐。

C/C++因为追求性能而不得不更加底层，不同平台的开发工具链不尽相同，各平台还有自己私有的系统API，导致媲美JNP开发体验的IDE是不存在的。熟练的C++开发者都有随时脱离IDE面对Terminal进行开发的能力，对语言掌握的要求就相对提高了。一些编译、链接的细节也需要开发者理解，并能亲自处理，缺乏掌握的后果可能是面对满屏的链接错误不知道何处下手。

固有思维模式带来的更致命的第二个问题是JNP开发者通常**对系统资源（内存、CPU等）的关注不足**，缺少一种在脑子里想象“现在写下的代码在怎样使用CPU，内存里在发生什么”的贯通性思考习惯，因为这一切都被虚拟机托管了。而这一习惯对于理解C/C++怎样工作、性能提升、定位复杂问题都至关重要。

```C++
// 调用如下函数，内存中的对象是怎样变化的？
std:vector<float> add_vectors(std::vector<float> a, std::vector<float> b)
{
    size_t n = a.size();
    std::vector<float> res(n, 0.0);
    for(auto i = 0; i < n; i++){
        res[i] = a[i] + b[i];
    }
    return res;
}
```

对于熟练的C开发者，情况就不一样了。他们对底层资源有良好的把控能力，即使不用C++，C语言本身也已经足够写出结构良好的代码。C语言有紧凑且稳定的语法集合，“多一点显得邋遢，少一点显得不够”，比汇编好写，又能精准操纵系统资源，一切都刚刚好。他们学习C++没有根本性的障碍，唯一的问题是愿不愿意进一步了解新的语法和编程范式。

## 总结

综上，有效地学习C++需要从两个方面入手。

首先，培养对系统资源（内存、CPU等）的理解和认识，把系统资源放在核心位置。既然需要使用C++，十有八九对性能有所要求，但性能不会因为“使用了C++”而自动变好，而是需要对资源使用情况进行反复审视。

其次，了解并理解各种设计实现背后的原因和历史，进而拥有独立做出权衡的能力。这需要在实践中逐渐琢磨、积累。机械记忆条条框框的原则无济于事，没有什么原则是永远正确的。C++的标准还在不断演进中，唯有理解背后的动机，以不变应万变，才能持续快速地吸收新的、对自己工作有帮助的语言特性。
