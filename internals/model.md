# 什么是对象模型

Lippman在《Inside C++ Object Model》一书中将对象模型定义为C++语言在两个层次上的约定：

* 对上的语法规则，例如class、virtual function等C++标准提供给用户的功能。
* 对下的实现机制，例如编译器如何实现virtual function，进而交给机器执行。

包括《C++ Primer》在内，很多书对前者，也就是C++的语法，做了非常多的介绍，找到一本好书很容易。介绍后者的资料相对要少得多。而根据C++开发者的经验，对后者的了解会带来很多好处，例如：

* 理解C++语法特性背后的动机和实现方式，进而能够分析为什么会有这样或者那样的设计，以及各种编译时、运行时的行为，变“被动记忆”为“主动分析”。
* 探索一门编译型语言的编译器如何在底层机器指令和高层语法特性之间进行抽象和转换。

## 一个例子

在C++中，通过前向声明A类，可以避免在B类的头文件中include A类的头文件，但是B类中如果包含有A类型数据成员就不能这么做。

```c++
// b.h

// 错误：B类包含A类型成员，必须 #include "a.h"
class A;
class B
{
public:
    string name() { return "A";}
private:
    A a;
};

// 正确：B类包含A类型指针成员，可以使用A类的前向声明，避免 #include "a.h"
class A;
class B
{
public:
    string name() { return "B";}
private:
    A* a;
};
```

类的定义提供了类的“规格说明”，编译器依据这些信息得知如何在内存中创建该类型的对象，检查后续在对象上的操作是否合法。

在前一种情况中，B类型包含一个A类型的数据成员。截止到B类型的定义处，没有A类的接口文件(头文件)可以参考，编译器不可能知道B类大小是多少、在内存中该如何创建等等。未来包含`b.h`的源文件中对B类的操作都将无法进行下去。所以这种写法是非法的。

在后一种情况中，B类型只包含一个A类型的指针。无论A类型的布局怎样，A*都是一个8 bytes(64位编译器)的指针，这时候不需要A的头文件也已经拿到了创建和操作B所需要的完整信息。这是是一种合理的写法。

这种推理的方式比记忆来得舒服地多，也更不容易忘记。对C++对象模型以及内存布局的了解，能够帮助我们从“记忆规则”更多地转向“分析原因”。

## 继续阅读

对象模型提供了编译器如何实现C++语言特性的细节。《Inside C++ Object Model》以数据成员、成员函数、构造、析构、拷贝和执行期语义为主线对它们进行了一一介绍，这种思路可以做到面面俱到。出于快速把握重点问题考虑，接下来三节会换一个角度，从面向对象三大特性的角度重新出发：

* 封装。类的数据成员、成员函数在内存中的布局是怎样的？
* 继承对类的内存布局有什么影响？
* 多态对类的内存布局有什么影响？
