# C++无用论

对于某些特定的领域，选择何种编程语言来完成工作是约定俗成的。比如，嵌入式编程常用C或者汇编，FPGA/DSP编程常用VHDL。受限于硬件性能或市场垄断等诸多原因，这些领域在一定时间内形成了自己特定的开发工具链，很容易作为共识被接受并使用。

开发运行在客户端（PC）或服务器端应用层的程序时，情况则不太一样。通常有大量语言摆在面前，该选什么就不是随口能回答的了。不过，这种选择通常在Java/Python/JavaScript/C#等之间进行，C/C++作为“复杂”的语言，是最后的选择，有一百种办法拒绝或绕过它。C/C++在面向业务的系统开发中真的这么没有用吗？本节将从三个方面提出不同的看法，更加客观理性地探讨一次其中的取舍。

## 时间和金钱

谈优劣不能脱离场景，我们来观察一个具体的案例。网络服务对并发量存在要求，用C++来实现似乎合情合理，但有说法认为，这其实是刻板印象。一个在线服务的端到端耗时分为两部分：服务端运算和网络传输。如果运算耗时在端到端耗时中占比很小，即使用C++实现比Python快十倍(假设分别为1ms和10ms)，并不能改变延迟高低由网络开销主导的事实。此时，用C++去追求足以被网络延迟掩盖的9ms的意义在哪呢？

这个挑战合乎逻辑。对于客户端程序，或者是用户不多（并发量小）的服务端程序，没有必要为了降低一点点用户根本感知不到的延迟选择一门开发难度更高的语言，尤其是大型团队存在开发水平和风格参差不齐的时候。粗放使用甚至适当浪费硬件资源的富余，换取更好的开发体验是明智之举。不过换到有些场景下，这个逻辑并不成立。

有些程序对延迟极其敏感，以快取胜，对性能的追求没有止境。例如高频交易，大量用户竞速，毫秒的差距足以带来区别。想要获得优势，除了拥有高速的网络环境，程序本身极致的性能也必不可少。此时，使用C/C++甚至汇编是不为过的。

另一些网络服务则拥有海量用户，动辄需要一个或多个机房的机器满负荷运行。运算时间每压缩一倍，就意味着QPS提升一倍，面对相同的流量就能节省50%的机器。快就意味着省钱，这和网络传输时间无关。

## 跨平台

讨论程序在平台间的可移植性需要清醒的认知。选择队伍不能只靠[标语口号](https://www.oracle.com/java/)，而是需要一些经验、教训或是勇气。

![Java](pic/java.png)

提到跨平台语言，Java、C#、Python以及JavaScript这些基于虚拟机或解释执行机制的语言总是首先被想到，C++和跨平台是不沾边的。举例来说，Oracle为多少平台实现了Java虚拟机，Java程序就能跨多少平台，其跨平台能力受益于Java虚拟机在各大平台上的广泛实现。C++程序被认为无法跨平台的原因是，它的可执行程序是平台相关的机器码。但是，基于标准特性的C++代码可以做到同一份源码能被不同平台上的C++编译器编译。因此，在源码层面上，C++是有一定跨平台能力的。

那么，到底选谁呢？场景说了算。如果想要程序能同时运行在Windows/Linux/Mac PC上，Java是很不错的选择。如果还要能同时运行在Android/iOS上，Java仍然是有竞争力的选择。但是，劣势已经开始显现，iOS的主流开发语言并不是Java，尽管由于Java的流行，iOS对它的支持一直在稳步推进，脱离主流选择Java还是难免招致一些不便。如果还想要程序在浏览器中运行，选择Java就十分不便了。

C++有时反而提供了优势。绝大多数平台都会提供C++编译器，用来编译性能优化的原生代码。只要程序不涉及网络、UI等操作系统和硬件相关的资源，标准的C++代码还是很有可能被绝大多数平台支持的。具体来看，用C++实现跨平台的机器学习算法库是合理的，它的核心操作建立在通用的内存数据结构和算法之上。而用C++写一个跨平台的UI库，就不是非常明智的选择，这是在和平台主流生态做对抗。这方面有一个鲜活的例子。2019年，dropbox[宣布](https://dropbox.tech/mobile/the-not-so-hidden-cost-of-sharing-code-between-ios-and-android)他们即将抛弃在iOS和Android间共享一套C++代码的做法，宁愿用Swift和Kotlin写两遍代码。

![The Hidden Cost of Sharing Code between iOS and Android](pic/dropbox_abandon_cpp.png)

## 抽象和性能

抽象分层是软件系统应对复杂问题的基本方法。例如，TCP/IP协议栈每层只专注部分功能，层层向上交付，最终实现数据的可靠传输。换到编程语言还是同样的思路，代码由高级语言经编译器转换为中间语言，再生成机器码。TCP/IP没有选择一层做完所有事情，开发人员也没有选择直接写出最终机器码，都是出于复杂度太高、可维护性太差的考虑。在这些复杂问题上，抽象分层从一开始就会被考虑。

“层次”也有可能是逐渐形成的。例如，为历史遗留软件增加新功能时，继续在外围封装新的一层而不是深入内部进行重构，是经常被求稳的开发者采用的策略。不是只有小公司或者水平不佳的开发者才会这么做，大公司耳熟能详的产品很多也是一样的。这种懒惰的做法，尽管浪费一点，却提供了较好的兼容性和稳定性，综合代价是短期内最小的。

但是，不停地抽象、封装和分层在提升复用性和开发效率的同时，很可能会走入困境：每层都是最优解，组合起来却得不到全局最优解。换句话说，抽象封装和性能会相互制约。优秀的设计可以缓解冲突，但改变不了冲突的本质，更优的性能意味着抽象封装需要被打破。

```cpp
/* 已有高效实现的函数封装：*/
// split将字符转按空白字符切割为tokens
vector<string> split(string& str);
// count对vector元素个数进行计数
int count(vector<string>& vec);

/* Task：计算string的token个数 */
// 仅对token个数感兴趣，不需要切分结果时，组合以上函数并不是最高效的实现
vector<string> tokens = split(str);
int len = count(toekns);
```

具体到编程语言，更高级的语言通常做了更多的抽象封装，让人用起来更省心，这背后通常是拿了性能做交换。例如，Python的动态类型让Json这一数据结构表达起来特别舒服，但频繁的`box/unbox`也给它的运行速度提升设置了很大障碍，和“int就是干干净净4个字节”的C/C++比性能，是很难的。

随着设备的硬件配置越来越高，一些开发框架、SDK或最终产品也在抽象封装的路上越走越远，在资源利用方面却显得越来越不克制。面对耗费大量资源的抱怨时，它们会拿出一个无法反驳的聪明回答：机器的资源那么多，空着不用干嘛呢？充分利用资源换取开发效率不是最经济的做法吗？这种想法本来是没错的，但是它助长了开发者懒惰、贪婪的坏习惯，导致越来越多的资源怪兽被开发出来。随着时间推移，当它们被大量安装在用户设备上的时候，资源会越来越紧张，运行也越来越慢。接下来，硬件厂商为了扭转局面，会生产出更强的硬件来满足市场需求。于是，软件和硬件就在这种贪婪和弥补中交替向前。