# C++无用论

受限于硬件性能或市场垄断等诸多因素，在一些特定领域内，选择何种编程语言来完成工作是约定俗成的。比如，为嵌入式系统编程常用C或者汇编，为FPGA/DSP编程常用VHDL。这些领域在它们的发展过程中，形成了自己特定的开发工具链。

开发运行在桌面或服务器上的程序时，情况有所不同。有大量的高级语言摆在我们面前，该选什么不是非常清晰。不过，这种选择通常在Java、Python、JavaScript等之间进行，C++作为“复杂”的语言是最后的选择，有一百种办法拒绝或绕过它。C++在面向业务的系统开发中真的这么没有用吗？本节将从三个方面提出不同的看法，更加客观理性地探讨其中的取舍。

## 时间和金钱

我们从一个具体场景下的案例开始。网络服务S想要给用户尽量好的体验，因而对延迟有很高要求，于是开发者D1决定用C++来实现。但是，开发者D2认为D1将低延迟与C++联系起来是基于自己的刻板印象。理由是，一个在线服务的端到端耗时分为两部分：服务端运算和网络传输，如果运算耗时占比很小，即使C++实现比Python快十倍(假设分别为1ms和10ms)，并不能改变延迟高低由网络开销主导的事实，用C++去追求足以被网络延迟掩盖的9ms的意义在哪呢？

这一挑战的关注点在于延迟，对于用户不多（并发量小）的网络服务，确实没有必要为了降低一点点用户根本感知不到的延迟选择一门开发难度更高的语言。对于大型团队来说，还常常存在开发者水平和风格参差不齐的问题，粗放地使用富余的硬件资源，换取更好的开发体验是明智的。

当我们的关注点不再只停留于延迟，而是还需要吞吐量的时候，坚持以上逻辑就不合适了。如果网络服务S拥有海量的用户，需要一个或多个机房的机器满负荷运行才能处理巨大的流量，那么运算时间每压缩一倍，就意味着QPS提升一倍，面对相同的流量就能节省50%的机器。快就意味着省钱，这和网络传输时间无关。

如果网络延迟不再是主导，延迟可能会再次成为焦点。有些程序对延迟极其敏感，以快取胜，对性能的追求没有止境。例如，高频交易中大量用户竞速，毫秒的差距就会带来损失，想要获得优势，除了拥有高速的网络环境，程序本身极致的性能也必不可少。此时，使用C/C++甚至汇编并不为过。

## 跨平台

跨平台是高级编程语言的主要设计目标之一。作为开发者，我们真正关心的是避免重复开发，即能否开发一次，多处执行，其它的因素是相对次要的。讨论代码在平台间的可移植性，需要把一些既有的印象和[结论](https://www.oracle.com/java/)放在一边，回到原始的、真正的问题和目标，总结经验和教训，得到新的认识。

![Java](pic/java.png)

提到跨平台语言，Java、C#、Python以及JavaScript这些基于虚拟机的语言总是首先被想到。Java的跨平台能力受益于Java虚拟机在各大平台上的广泛实现，Oracle为多少平台实现了Java虚拟机，预先编译的Java字节码就能跨多少平台。C++程序被认为无法跨平台的原因是，它的可执行程序是平台相关的机器码。但是，为不同平台分别编译真的是一个无法接受的代价吗？所谓的一次编译，多处运行是我们必须要到达的目标吗？未必，此时基于C++标准的源代码一样是跨平台的。

没有完美的语言。如果想要程序能同时运行在Windows/Linux/Mac PC上，Java是很不错的选择。如果还要能同时运行在Android/iOS上，Java仍然是有竞争力的选择。但是，劣势已经开始显现，iOS的主流开发语言并不是Java，尽管由于Java的流行，iOS对它的支持一直在稳步推进，脱离主流选择Java还是难免招致一些不便。如果还想要程序在浏览器中运行，选择Java就十分不便了。

C++有时反而提供了优势。绝大多数平台都会提供C++编译器，用来编译性能优化的原生代码。只要程序不涉及网络、UI等操作系统和硬件相关的资源，标准的C++代码还是很有可能被绝大多数平台支持的。具体来看，用C++实现跨平台的机器学习算法库是合理的，它的核心操作建立在通用的内存数据结构和算法之上。而用C++写一个跨平台的UI库，就不是非常明智的选择，这是在和平台主流生态做对抗。这方面有一个鲜活的例子。2019年，dropbox[宣布](https://dropbox.tech/mobile/the-not-so-hidden-cost-of-sharing-code-between-ios-and-android)他们即将抛弃在iOS和Android间共享一套C++代码的做法，宁愿用Swift和Kotlin写两遍代码。

![The Hidden Cost of Sharing Code between iOS and Android](pic/dropbox_abandon_cpp.png)

## 抽象分层和性能

抽象分层是应对复杂问题的基本方法。作为普适的方法论，它在计算机软硬件的发展历程中扮演的角色是举足轻重的。

* TCP/IP协议栈每层只专注部分功能，层层向上交付，最终实现数据的可靠传输。网络协议设计时，没有选择一层做完所有事情。
* 用高级编程语言编写的程序，需要经过编译器转换为中间语言，然后生成机器码，最终交给CPU执行。

“层次”也有可能是逐渐形成的。例如，为历史遗留软件增加新功能时，继续在外围封装新的一层而不是深入内部进行重构，是经常被求稳的开发者采用的策略。不是只有小公司或者水平不佳的开发者才会这么做，大公司耳熟能详的产品很多也是一样的。这种懒惰的做法，提供了较好的兼容性和稳定性。

分层带来的优点，我们已经习以为常了，其中最为重要的一点是解耦。不同层次对外形成稳定的接口只是解耦带来的结果之一，解耦的影响还体现在将开发人员划归不同的阵营。来自不同阵营的开发者只需要精通自己的一层，各司其职、分工协作，就能解决复杂问题，最终收获自己“垄断”的领域知识带来的收益。

抽象分层在提升复用性和协作效率的同时，终究会走入困境：每层都是最优解，组合起来却得不到全局最优解。

为了感受这一点，我们看下面的例子。假设我们将对字符串的操作封装为一个库，希望未来的需求都能在它的基础上实现，而不需要再接触字符串的存储和实现细节。这个库里面包含如下两个函数：`split`和`count`。

```cpp
// split将字符转按空白字符切割为tokens
vector<string> split(string& str);

// count对vector元素个数进行计数
int count(vector<string>& vec);
```

某一天，上层出现了这样一个需求：计算string的token个数，不需要切分结果。此时，组合以上函数并不能得到最高效的实现，因为将字符串切分成tokens并存储起来的开销是可以避免的，我们只需要遍历一遍字符串，数出其中空白字符的个数。

```cpp
vector<string> tokens = split(str);
int len = count(toekns);
```

分层带来的另一个问题是，它助长了开发者懒惰、贪婪的坏习惯。面对资源无畏损耗的质疑，部分开发者是视而不见的，他们指望底层资源的富余来弥补层次带来的损耗：机器资源那么多，空着不用干嘛呢？充分利用资源换取开发效率不是最经济的做法吗？随着时间推移，资源富余逐渐被消耗殆尽，硬件厂商为了扭转局面，生产出更加强大的硬件来满足市场需求，贪婪和补偿构成了软硬件交替向前发展的动力。

理想情况下，从高级语言到CPU指令集进行一体化设计才是榨干硬件能力的终极之路。但是，这不仅在技术上有难度，也需要重新划分产业上下游的蛋糕，并不是一条平坦的解决之道。于是，我们看到，今天有人鼓吹抽象分层是完美的设计，明天就有人宣扬跨层软硬件协同设计才是未来，甚至在两者之间来回横跳的是同一批人。

作为应用层开发者，很遗憾，C/C++是我们离底层硬件最近的选择。掌握C/C++的过程是我们理解普遍存在的分层和性能之间矛盾的过程，也是我们习得一门武器，在必要的时候去解决性能问题的过程。

![Developers Today](pic/developers.jpg)
