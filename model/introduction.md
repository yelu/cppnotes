# 什么是对象模型

Lippman在《Inside C++ Object Model》一书中将对象模型定义为C++语言在两个层次上的约定：

* 对上的语法规则，例如class、virtual function等C++标准提供给用户的功能。
* 对下的实现机制，例如编译器如何实现virtual function。

包括《C++ Primer》在内，很多书对前者，也就是C++的语法，做了非常多的介绍，找到一本好书很容易。介绍后者的资料相对要少得多。而根据C++开发者的经验，对后者的了解会带来很多好处，例如：

* 理解C++特性背后的动机，为什么会有这样或者那样的行为。
* 满足探索C++编译器如何实现的好奇心。

## 一个例子

在C++中，通过前向声明A类，可以避免在B类的头文件中include A类的头文件，但是B类中如果包含有A类型数据成员就不能这么做。

```c++
// b.h

// 错误：B类包含A类型成员，不能不 #include a.h
class A;
class B
{
public:
    virtual string GetName() { return "A";}
private:
    A a;
};

// 正确：B类包含A类型指针成员，可以使用A类的前向声明，避免 #include a.h
class A;
class B
{
public:
    virtual string GetName() { return "B";}
private:
    A* a;
};
```

类的定义提供了有关“在内存中如何创建该类型对象”的信息，编译器依据该信息检查后续在B类型对象上的操作是否合法，并生成操作指令。在需要的时候，编译器生成的指令能够在内存中创建B类型实例：

* 申请一块sizeof(B)大小的内存。
* 调用构造函数写入正确的初始化数据。

在前一种情况中，编译器没有拿到A类的接口文件（头文件），不可能知道A的大小。随之，B的大小也没法确定，编译器无法工作下去。

在后一种情况中，B类型只包含一个A类型的指针，无论A类型的布局怎样，A*都是一个8 bytes（64位编译器）的指针，这时候不需要A的头文件也已经拿到了创建和操作B所需要的完整信息，因此是一种合理的写法。

对C++对象模型以及内存布局的了解，帮助我们完成了一次从“记忆规则”到“分析原因”的转变。

## 继续阅读

对象模型提供了编译器如何实现C++语言特性的细节。《Inside C++ Object Model》以数据成员、成员函数、构造、析构、拷贝和执行期语义为主线对它们进行了一一介绍。而本章余下各节会换一个角度，从面向对象三大特性的角度来重新看待部分重点问题：

* 封装。类的数据成员、成员函数在内存中的布局是怎样的？
* 继承对类的内存布局有什么影响？
* 多态对类的内存布局有什么影响？
