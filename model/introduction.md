# 什么是对象模型

Lippman在《Inside C++ Object Model》一书中将对象模型定义为C++语言在两个层次上的约定：

* 对上的语法规则，例如class、virtual function等C++标准提供给用户的功能。
* 对下的实现机制，例如编译器如何实现virtual function。

包括《C++ Primer》在内，很多书对前者，也就是C++的语法，做了非常多的介绍，找到一本好书很容易。介绍后者的资料相对要少得多。而根据C++开发者的经验，对后者的了解会带来很多好处，例如：

* 理解C++特性背后的动机，为什么会有这样或者那样的行为。
* 满足探索C++编译器如何实现的好奇心。

## 一个例子

在C++中，通过前向声明A类，可以避免在B类的头文件中include A类的头文件，但是B类中如果包含有A类型数据成员就不能这么做。

```c++
// b.h

// 错误：B类包含A类型成员，不能不 #include a.h
class A;
class B
{
public:
    virtual string GetName() { return "A";}
private:
    A a;
};

// 正确：B类包含A类型指针成员，可以使用A类的前向声明，避免 #include a.h
class A;
class B
{
public:
    virtual string GetName() { return "B";}
private:
    A* a;
};
```

编译器在内存中构造B类型实例的步骤是这样的：

* 申请一快sizeof(B)大小的内存。
* 调用构造函数写入正确的初始化数据。

在前一种情况中，编译器没有拿到A类的接口文件（头文件），就不知道A的大小。随之，B的大小也没法确定，编译无法进行下去。

在后一种情况中，B类型只包含一个A类型的指针，无论A类型的布局怎样，A*都是一个8 bytes（64 bits）的指针，这时候不需要A的头文件也能知道B的大小，因此是一种合法的写法。

## 继续阅读

对象模型提供了很多编译器实现C++语言特性的细节，《Inside C++ Object Model》以数据成员语义、成员函数语义、构造、析构、拷贝语义和执行期语义为主线对他们进行了一一介绍。本章余下各小节会从面向对象三大特性的角度来重新看待部分重点问题，包括：

* 封装。类的数据成员、成员函数在内存中的布局是怎样的？
* 继承对类的内存布局有什么影响？
* 多态对类的内存布局有什么影响？
