# 内部链接与外部链接

## 声明(Declaration)

一个声明将一个名称引入一个作用域，在c++中，在一个作用域中重复一个声明是合法的，以下均为声明：

```c
    1.int foo(int,int);    //函数前置声明
    2.typedef int Int;     //typedef 声明
    3.extern int g_var;    //外部引用声明
    4.class bar;           //类前置声明
    5.using std::cout;     //名字空间引用声明
    6.friend test;         //友员声明
    有两种声明不能重复，那就是类成员函数及静态数据成员的声明
    class foo
    {
        static int i;
        static int i;//不可以
        int foo();
        int foo();//不可以
    };
```

## 定义(Definition)

一个定义提供一个实体(类型、实例、函数)在一个作用域的唯一描述。在同一作用域中不可重复定义一个实体，以下都是定义：

```c
    1.int y;
    2.static int i;
    3.extern int i = 10;有初始化值的extern被认为是定义
    4.const double PI = 3.1415;
    5.void test(int p) {};
    6.class foo {...};
    7.foo a;
    8.struct bar {...};
    9.bar b;
    10.enum Color{RED,GREEN,BLUE};
    11.union Rep{...};
```

## 头文件、源文件及编译单元

当一个c或cpp文件在编译时，预处理器首先递归包含头文件，形成一个含有所有必要信息的单个源文件,这个源文件就是一个编译单元。这个编译单元会被编译成为一个与cpp文件名同名的目标文件(.o或是.obj)。连接程序把不同编译单元中产生的符号联系起来，构成一个可执行程序。

首先,我们可以将所有东西都放在一个.cpp文件内.然后编译器就将这个.cpp编译成.obj,obj是什么东西?就是编译单元了.一个程序,可以由一个编译单元组成,也可以有多个编译单元组成. 如果你不想让你的源代码变得很难阅读的话,就请使用多个编译单元吧.(一个函数不能放到两个编译单元里面,但两个以上就可以分别放在一个单元,也就是cpp里面)那么就是一个.cpp对应一个.obj,然后将所有的obj链接起来(通过一个叫链接器的程序),组成一个.exe,也就是程序了.

如果一个.cpp要用到另一个.cpp定义的函数怎么办? 只需在这个.cpp种写上他的函数声明就可以了.其余工作由链接器帮你完成,你可以随便调用该函数.链接器将所有的obj连接起来,但是如果碰巧有相同的函数或外部变量怎么办?他如何识别?一般来说是不能允许在同一个程序中,出现两个一样的函数名或外部变量名.但是只得庆幸的是,c++可以通过一种叫做链接属性的关键字来限定,你这个函数是属于整个程序公用的,还是只是在一个编译单元obj里面使用的.这些关键字就是extern和 static：

* extern是外部链接的意思,也就是除了这个单元,外部的单元也是能够访问这个函数的。
* static 是内部链接,只属于自己编译单元。

说了这么久,还没有说.h的作用呢?其实没有.h也能很好的工作,但是当你发现一个外部链接的函数或外部变量,需要许多份声明,因为c++这种语言,在使用函数和变量的时候,必须将他声明,为何要声明?声明之后才知道他的规格,才能更好的发现不和规格的部分.你别妄想一个编译单元,会自动从另一个编译单元那里得到什么信息,知道你是如何定义这个函数的.所以说,只要使用到该函数的单元,就必须写一份声明在那个.cpp里面,这样是不是很麻烦,而且,如果要修改,就必须一个一个修改.这真让人受不了..h就是为了解决这个问题而诞生,他包含了这些公共的东西.然后所有需要使用该函数的.cpp,只需要用#include包含进去便可.以后需要修改,也只是修改一份内容.请注意不要滥用.h,.h里面不要写代码,.h不是.cpp 的仓库,什么都塞到里面.如果在里面写代码,当其他.cpp包含他的时候,就会出现重复定义的情况,比如将函数func(){printf}；放到头文件 a.h,里面还有一些a.cpp需要的声明等；然后你发现b.cpp需要用到a.cpp里面的一个函数,就很高兴的将a.h包含进来.注意,#include并不是什么申请指令,他就是将指定的文件的内容,原封不动的拷贝进来.这时候实际上a.cpp和b.cpp都有一个func()函数的定义.如果这个函数是内部链接static的话,还好,浪费了一倍空间；如果是extern,外部链接(这个是默认情况),那么根据在同一个程序内不可出现同名函数的要求,连接器会毫不留情给你一个连接错误!如果你还不太理解.那么就尝试不用h,只用多个cpp看看应该如何写.尝试在两个cpp中写同名函数.看看是否链接出错.尝试在cpp使用其他cpp定义的函数.看看应该如何做.

头文件是没有编译意义的,一般只是编译.cpp生成.obj.但是.cpp里面有#include将指定头文件(其实任何文件都行)插进来,组成完整的.cpp.如果你不喜欢这个方式,你也可以直接在.cpp里面写好了,而不放到.h里面,载用指令拷贝进来.头文件是工具,但不是必须.

## 自由函数

如果一个函数是自由函数，那么这个函数不是类的成员函数，也不是友元函数。

如果一个名称对于它的编译单元来说是局部的，并且在连接时不会与其它编译单元中的同样的名称相冲突，那么这个名称有内部连接(注：有时也将声明看作是无连接的，这里我们统一看成是内部连接的)。以下情况有内部连接:

* 所有的声明
* 名字空间(包括全局名字空间)中的静态自由函数、静态友元函数、静态变量的定义(除了类中)
* enum定义
* union的定义
* inline函数定义(包括自由函数和非自由函数)
* 类的定义
* 名字空间中const常量定义

在一个多文件程序中，如果一个名称在连接时可以和其它编译单元交互，那么这个名称就有外部连接。以下情况有外部连接:

* 类非inline函数总有外部连接。包括一般类成员函数、静态成员函数、虚函数。
* 类静态成员变量总有外部连接。
* 名字空间(包括全局名字空间)中非静态自由函数、非静态友元函数及非静态变量
