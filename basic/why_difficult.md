# C++复杂论

如果用一个词来概括开发者对C++的集体感受，恐怕是又爱又恨。

自98年被标准化以来，C++历经03/11/14/17标准，也将迎来最新的20标准。期间，繁荣的IT互联网产业在系统的很多部分都得益于这门“古老又年轻”语言。作为基础设施的高并发网络服务后台中，到处都有C++的身影。

与此同时，C++还被认为是一门比较难以掌握的语言。有太多人基于自身立场，对C++表达过意见和不满：C++太底层了什么都要自己管，语法太庞杂记不住，标准进化太快，模板、元编程太魔法不知道在干啥等等。尽管这些解释提供了部分事实，但更像是已经熟悉C++的群体的内部讨论。在有能力合理使用C++之前，初学者很难真正体会到相比其它语言C++到底难在哪里，彻底回答这个问题需要结合长期的思考和体会。

鉴于此，与其在技术细节层面列举枯燥的语法特性找寻答案，我们尝试从侧面寻求一些非具体语法特性方面的原因，这是本节想要接近的目标。了解这些原因也许有助于清除一些陷阱和偏见，以一个更加全局的视角开始学习或者重新认识C++。

## C++提供了太多可能性

总体上看，C++的语法特性确实复杂度比较高，而且还在持续变得越来越复杂。

|语言|Keyword数量|
|--|--|
|C|[32](http://tigcc.ticalc.org/doc/keywords.html)|
|C++98|[79](https://en.wikibooks.org/wiki/C%2B%2B_Programming/Programming_Languages/C%2B%2B/Code/Keywords)|
|C++11|+12|
|C++20|+8|
|Java|[50](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html)|
|C#|[77+31](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/)|
|Python|[33](https://www.w3schools.com/python/python_ref_keywords.asp)|

这一点很容易被误读，语法集合的大小和使用的难易程度没有必然联系，keyword最多的C#反而不那么难上手。真正的原因是C++出于很多考虑提供了太多方式和自由度，以至于完成一件事可以有很多条道路，进而产生了选择性困难：
* 各种写法都多少存在一些陷阱，在没有全面了解的情况下很容易掉入。
* 开发者群体通常持有不同的观点或者“信仰”，坚持不同的原则和使用方式。

通过“字符串连接”这个简单的例子能很快了解到问题所在。

如果是python，除非极其特殊的原因，几乎不会有人写出不同于以下的另一种实现：

```python
def concat_str(a: str, b: str):
    return a + b
```

到了C++这里麻烦却很大。首先，执着于C的程序员可能会马上提出意见：字符串需要用char数组来存储，我不习惯用C++的std::string类。那么存放结果的buffer在哪？这又是一次选择的开始：

* 谁申请谁释放原则。存放结果的数组以参数的形式传进去，再加一个大小防止函数写越界。
* 函数对外屏蔽实现原则。用多少申请多少，由函数内部分配并返回，调用者释放。

```c
void concat_str(char* a, char* b, char* dst, int n);
char* concat_str(char* a, char* b);
```

两者都是合法的，但是通常大家习惯采用第一种，即由调用者控制内存的申请，以尽量规避内存归属不清导致的泄露。初学者在没有经验的时候并不容易把握到这一点。

回到习惯C++ std::string类的开发者，如果不是性能要求特别苛刻，使用std::string也能简单直观地实现功能，但这其中还是有一些选择需要面对：

* const、引用等等，用还是不用？
* 该返回std::string吗？返回值的复制能避免吗？这牵涉到对返回值优化RVO(Return Value Optimization)，以及左值右值的了解。

```c++
std::string concat_str(const std::string& a, const std::string& b)
{
    std::string res = a + b;
    return res;
}
```

所以，无所适从才是头疼之处。好像怎么做都行，但是一做就错，如履薄冰。

## 从其它语言带入的固有思维模式

固有思维模式是一种先入为主的陷阱，它首先体现在对开发环境的要求上面。

经常使用Java/.Net/Python的开发者（以下简称JNP开发者）对C++复杂性的认识有一部分是错觉。Java和.Net开发者几乎都会使用某一IDE做开发，这些语言都有中间虚拟机，语言标准由寡头掌控，统一且跨平台一致，IDE可以做得非常完美，智能提示和补全在很大程度上弥补了语法特性带来的复杂性。而Python正是靠着绝对符合直觉的语法设计才备受亲睐。

C/C++因为追求性能而不得不更加底层，不同平台的开发工具链不尽相同，各平台还有自己私有的系统APIs，导致媲美JNP开发体验的IDE是不存在的。熟练的C++开发者都有随时脱离IDE面对Terminal进行开发的能力，对语言掌握程度的要求就相对提高了。一些编译、链接的细节也需要开发者理解，并能亲自处理，缺乏掌握的后果可能是面对满屏的链接错误不知道何处下手。

固有思维模式带来的更致命的第二个问题是JNP开发者通常**对系统资源（内存、CPU等）的关注不足**，缺少一种在脑子里想象“现在写下的代码在怎样使用CPU，内存里在发生什么”的贯通性思考习惯，因为这一切都被虚拟机托管了。而这一习惯对于理解C/C++怎样工作、性能优化、定位复杂问题都至关重要。

```C++
// 调用如下函数，内存中的对象是怎样变化的？
std:vector<float> add_vectors(std::vector<float> a, std::vector<float> b)
{
    size_t n = a.size();
    std::vector<float> res(n, 0.0);
    for(auto i = 0; i < n; i++){
        res[i] = a[i] + b[i];
    }
    return res;
}
```

对于熟练的C开发者，情况不太一样，他们对底层资源已经有了良好的把控能力。在他们看来，C语言语法集合紧凑且稳定，“多一点显得邋遢，少一点显得不够”，比汇编好写，又能精准操纵系统资源，有标注库可以跨平台，一切都刚刚好。这时候，学习C++唯一的障碍便是没有意愿进一步了解新的语法和编程范式。例如，拿C语言的哲学去评判C++ 20中引入的Module和Coroutine，简直是走火入魔。这是定位的不同造成的，C++曾经把对C语言的兼容性写进了标准，但C语言早已不在C++舞台的中央了。

过于坚守C语言的立场容易走向极端。高级语言是为了减轻开发人员的思考负担服务的，C语言的语法集合精简也意味着实现相同的功能通常需要更加违背直觉的方式。今天，我们并不缺少改进工具链的人和技术。这意味着，即使历史上C++没有出现，也会有另外一门类似的语言被发明出来承担所谓“改进”C语言的任务。理解和反思是不断向前所必需的。

## 如何学习？

有效地学习C++需要结合以下两个方面。

首先，认识、理解C++和系统资源（内存、CPU等）之间如何互动，把系统资源放在核心位置。资源利用率就是性能，而性能是C/C++永远不会妥协的重点。性能不会因为“使用了C++”而自动变好，而是需要对资源使用情况进行反复审视。

其次，认识、理解各种设计实现背后的原因和历史，进而拥有独立做出权衡取舍的能力。这需要在实践中逐步积累。机械地记忆条条框框无济于事，没有什么原则永远正确，没有什么模式放之四海皆准。C++的标准还在不断演进中，唯有理解背后的动机，才能持续快速地吸收新的、对自己工作有帮助的语言特性。
