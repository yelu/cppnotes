# C++无用论

有些领域经过长时间的发展，形成了自己特定的开发工具链，很容易作为一种常识被接受和使用。比如，嵌入式编程常用C或者汇编，FPGA/DSP编程常用VHDL。但是在PC客户端或者服务器端开发应用层软件时，通常有大量语言摆在面前，该选谁就不是随口能回答的问题了。

## 时间和金钱

谈优劣不能抛开了场景。有说法认为，在线服务后台用C++写并没有优势。一个在线服务的端到端耗时分为两部分：服务端运算和网络传输。如果运算耗时在端到端耗时中占比很小，即使C++版本的实现比Python快十倍(分别为1ms和10ms)，并不能改变延迟高低由网络开销主导的事实。此时，用C++去追求足以被网络延迟掩盖的9ms的意义在哪呢？

这个挑战合乎逻辑。对于调用次数少、用户不多的程序，无论运行在客户端还是服务端，都没有必要为了降低一点点用户根本感知不到的时间选择一门开发难度更高的语言，用微不足道的资源浪费换取更好的开发体验是明智之举。不过换到有些场景下，这个逻辑并不成立。

有些服务对延迟极其敏感，大量用户竞速、以快取胜。如高频交易，毫秒的差距足以导致交易损失，使用C/C++甚至是汇编都毫不为过。这类服务对性能的追求没有止境。

今天的很多互联网服务拥有海量用户，动辄一个或多个机房的机器满负荷运行。运算时间每压缩一倍，就意味着QPS提升一倍，面对相同的流量就能节省50%的机器。快就意味着省钱，这和网络传输时间无关。

## 跨平台

平台间的可移植性是一个更难讨论清楚的问题。选择队伍需要的是经验和教训，而不是贴在网站上的[标语](https://www.oracle.com/java/)。

![Java](java.png)

提到跨平台语言，Java/C#/Python总是首先被想到，C++和跨平台是不沾边的。Java跨平台的能力取决于Oracle的Java虚拟机跨平台的能力，有多少平台上有Java虚拟机实现，Java代码就能跨多少平台。C++被认为不跨平台是因为它的可执行程序是平台相关的机器码。但是，一些C++代码可以做到同一份源码能被多数平台上的C++编译器编译。在源码层面看，C++有一定的跨平台能力。

那么，到底谁更优秀呢？场景说了算。如果想要程序能同时运行在Windows/Linux/Mac PC上，何不选择Java呢？如果还要能同时运行在Android/iOS上，Java仍然是一个有竞争力的选择。但是劣势已经开始显现，iOS的主流开发语言并不是Java。尽管由于Java的流行，iOS对它的支持一直在稳步推进，脱离主流选择Java还是难免招致一些不便。更重要的一点是，Java程序能不能在某个平台上运行取决于某个公司或组织，不以某个开发者的意志为转移。如果还想要程序在浏览器中运行呢？是时候忘掉Java了。

C++有时反而提供了某种优势。绝大多数平台或者设备一出现就会提供一个C++编译器，用来编译性能优化的Native程序。只要程序不涉及网络、UI等系统和硬件相关的资源，标准的C++代码还是很有可能被绝大多数平台支持的。具体来看，用C++实现一个跨平台的机器学习库就很合适，它的核心操作是一些通用的数值运算。而用C++写一个跨平台的网络IO库、UI库，就不是一个非常明智的选择，这是在和平台主流生态做对抗。在这方面有一个很鲜活的例子。2019年，dropbox[宣布](https://dropbox.tech/mobile/the-not-so-hidden-cost-of-sharing-code-between-ios-and-android)他们即将抛弃在iOS和Android间共享一套C++代码的做法，宁愿用Swift和Kotlin写两遍代码。

![The hidden cost of sharing code between iOS and Android](dropbox_abandon_cpp.png)

## 封装和性能

抽象和分层是软件系统应对复杂问题的基本方式之一。例如，TCP/IP协议栈每层只专注部分功能，层层向上可靠交付，最终实现数据的可靠传输。换到程序开发还是同样的思路，代码由高级语言由编译器转换为汇编语言，再生成机器码。TCP/IP没有选择一层做完所有的事情，开发人员也没有选择直接写出最终的机器码，这都是出于复杂度太高的考虑。

封装大大提升了复用性和开发效率，有没有代价呢？当然有，抽象分层会导致一种结果，即每层都是最优解，组合起来却不是个全局最优解。性能和抽象封装在到达某个临界点后，会相互制约，继续优化性能就需要打破封装。

可以从一个缩小的局部例子来体会这一点。`split_string`是一个封装好的函数，返回切分完的token list。如果有个需求是仅获取string切分完的token数目，基于封装的做法只需简单地调用已有的函数，先split再获取结果的size。这其中的浪费很明显，获取token数目只需要遍历一遍就可以了，完全不需要去真正split它，而代价是实现一个全新的函数。

```cpp
// 基于封装的做法
vector<string> tokens = split_string(str_a);
int n = tokens.size();
```

回到编程语言，类似的困境依然存在。更高级的语言用起来更省心，这背后通常是拿了性能做交换。例如，Python的动态类型让Json这种数据结构表达起来特别舒服的同时，频繁的`box/unbox`也给它的运行速度设置了上限，永远不可能和C/C++里面int就是干干净净的4字节内存这种实现比性能。
